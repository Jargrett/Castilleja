library(litterfitter)#for k-curve fitting
library(ggplot2)
library(ggpubr)#extended functions for plottinglibrary(remotes)
library(ggpattern)
library(purrr)
conflicted::conflicts_prefer(dplyr::filter)
#load-in the data
within1 <- read.csv("Raw Data/Litter Decomposition - 2024 Within Season.csv")
within2 <- read.csv("Raw Data/Litter Decomposition - 2025 Within Season.csv")
overwinter1 <- read.csv("Raw Data/Litter Decomposition - 2024 Overwinter.csv")
overwinter2 <- read.csv("Raw Data/Litter Decomposition - 2025 Overwinter.csv")
year1 <- read.csv("Raw Data/Litter Decomposition - 2024 Full Year.csv")
year2 <- read.csv("Raw Data/Litter Decomposition - 2025 Full Year.csv")
twoyear <- read.csv("Raw Data/Litter Decomposition - 2023-2025 Two Year.csv")
found <- read.csv("Raw Data/Litter Decomposition - Found Bags.csv")
#Data Cleaning and Restructuring
within1 %<>%
filter(missing != "Yes") %>%
dplyr::select(-c((missing)))
within2 %<>%
dplyr::select(-c((missing)))
overwinter1 %<>%
filter(missing != "Yes") %>%
dplyr::select(-c((missing))) %>%
dplyr::select(-c((redo_coin_litter_dry_weight))) %>%
dplyr::select(-c((diff)))
overwinter2 %<>%
filter(ups_missing != "yes") %>%
dplyr::select(-c((ups_missing))) %>%
filter(missing != "yes") %>%
dplyr::select(-c((missing)))
year1 %<>%
filter(missing != "Yes") %>%
dplyr::select(-c((redo_coin_litter_dry_weight))) %>%
dplyr::select(-c((missing)))
year2 %<>%
filter(missing != "yes") %>%
dplyr::select(-c((missing)))
twoyear %<>%
filter(missing != "yes") %>%
dplyr::select(-c((missing)))
#Combine datasets
decomp <- bind_rows(within1, within2 , overwinter1, overwinter2, year1, year2, twoyear)
decomp <- as.data.frame(unclass(decomp),stringsAsFactors=TRUE)
#Calculate Mass Remaining and time
o <- 0.91
decomp %<>% mutate(mass_remaining = final_dry_weight/initial_dry_weight) %>%
mutate(time = deployment_duration/365) %>%
drop_na(time) %>%
filter(mass_remaining <= o) %>%
mutate(across(c("time"), ~ round(.x, 2)))
#function to fit weibull
fit.weibull.nls = function(time_data, mass_data){
fit = nls(mass_data ~ exp(- (time_data/beta)^alpha),
start = list(beta = 1, alpha = 1),
algorithm = "port",
lower = c(0.0001, 0.0001))
return(fit)
}
#create dataframe to add predictions of models (for plotting)
t <- expand.grid(time_data = seq(0, 2.5, 0.01))
#half-life calculation:
half.life.calc = function(nls.mod){
pars= coef(nls.mod)
hl=pars[1] * (log(2))^(1/pars[2])
names(hl) ="half.life"
return(hl)
}
#mean residence time calculation:
mrt.calc = function(nls.mod){
pars= coef(nls.mod)
mrt=pars[1] * gamma(1+(1/pars[2]))
names(mrt)="mrt"
return(mrt)
}
#funtion to fit all data within the dataframe
fit_extract_predict <- function(df, t) {
mod <- fit.weibull.nls(
time_data = df$time,
mass_data = df$mass_remaining)
hl  <- half.life.calc(nls.mod = mod)
mrt <- mrt.calc(nls.mod = mod)
pred <- predict(mod, t)
list(half_life = hl, mrt = mrt, pred = pred)
}
#create a results dataframe for each plot as well as a list object for predicitive line
weibull_results <- decomp %>%
group_by(plot, litter, removal) %>%
group_modify(~{
out <- fit_extract_predict(.x, t)
tibble(
half_life = out$half_life,
mrt = out$mrt,
pred = list(out$pred)
)
}) %>%
ungroup()
#create a new dataframe in long for for the predictive lines
pred_weibull <- weibull_results %>%
select(plot, litter, removal, pred) %>%
tidyr::unnest(pred) %>%
mutate(time_data = rep(t$time_data, times = nrow(weibull_results))) %>%
select(plot, litter, removal, time_data, pred)
conflicted::conflicts_prefer(labdsv::predict)
#create a new dataframe in long for for the predictive lines
pred_weibull <- weibull_results %>%
select(plot, litter, removal, pred) %>%
tidyr::unnest(pred) %>%
mutate(time_data = rep(t$time_data, times = nrow(weibull_results))) %>%
select(plot, litter, removal, time_data, pred)
write.csv(pred_weibull, "Processed Data/Weibull Predictions.csv", row.names=FALSE)
#create a results dataframe for each plot as well as a list object for predicitive line
weibull_results <- decomp %>%
group_by(plot, litter, removal) %>%
group_modify(~{
out <- fit_extract_predict(.x, t)
tibble(
half_life = out$half_life,
mrt = out$mrt,
pred = list(out$pred)
)
}) %>%
ungroup()
#create a new dataframe in long for for the predictive lines
pred_weibull <- weibull_results %>%
select(plot, litter, removal, pred) %>%
tidyr::unnest(pred) %>%
mutate(time_data = rep(t$time_data, times = nrow(weibull_results))) %>%
select(plot, litter, removal, time_data, pred)
write.csv(pred_weibull, "Processed Data/Weibull Predictions.csv", row.names=FALSE)
#subset for plotting
pred_cas <- pred_weibull %>%
filter(litter == "Castilleja") %>%
group_by(time_data, removal) %>%
summarise(mean = mean(pred), se = sd(pred)/sqrt(n()))
pred_com <- pred_weibull %>%
filter(litter == "Community") %>%
group_by(time_data, removal) %>%
summarise(mean = mean(pred), se = sd(pred)/sqrt(n()))
pred_mix <- pred_weibull %>%
filter(litter == "Mixed") %>%
group_by(time_data, removal) %>%
summarise(mean = mean(pred), se = sd(pred)/sqrt(n()))
#remove predictive lines to create final dataset
#cleaned dataframe for mrt and half_life plotting
summary_decomp <- weibull_results %>%
select(plot, litter, removal, half_life, mrt)
write.csv(summary_decomp, "Processed Data/Litter Decomp Values.csv", row.names=FALSE)
#plotting
decomp_mrt <- summary_decomp %>%
group_by(litter, removal) %>%
summarise(mean = mean(mrt),
se = sd(mrt)/sqrt(n())) %>%
mutate(pat = ifelse(removal == "R", "stripe", "none"))
decomp_hl <- summary_decomp %>%
group_by(litter, removal) %>%
dplyr::summarise(mean = mean(half_life),
se = sd(half_life)/sqrt(n())) %>%
mutate(pat = ifelse(removal == "R", "stripe", "none"))
#
ggplot() +
geom_line(data = pred_cas, aes(time_data, mean), color = "#4b3b40") +
geom_line(data = pred_com, aes(time_data, mean), color = "#9b7e46") +
geom_line(data = pred_mix, aes(time_data, mean), color = "#808f87") +
facet_wrap(~ removal) +
theme_pubr() +
labs(x = "time since deployment", y = "proportion of litter mass remaining")
#Mean Residence Time
ggplot(decomp_mrt, aes(x = litter , y = mean, fill = removal, pattern = pat)) +
geom_bar_pattern(stat = "identity", color = "black", alpha = 0.8, width = 0.92,
position = position_dodge(width = 0.92),
pattern_angle = 45, pattern_density = 0.12,
pattern_spacing = 0.02, pattern_fill = '#333d29', pattern_colour = NA) +
geom_errorbar(aes(ymin = mean - se, ymax = mean + se), width = 0.2, position = position_dodge(width = 0.92)) +
scale_fill_manual(values = c("#333d29", "#b6ad90")) +
scale_pattern_manual(values = c("none", "stripe")) +
theme_pubr() +
theme(legend.position = "none",panel.grid = element_blank()) +
ylim(0, 2.5) +
labs(x = "Litter Type", y = "Mean Resdience Time (yrs)")
setwd("~/Desktop/Castilleja/Data Analysis/RMBL Castilleja Experimental Project")
#----------Data importing, cleaning, and restructuring----------#
library(tidyverse)#for data wrangling and restructuring
library(magrittr)#for data wrangling and restructuring
library(plyr)#for data wrangling and restructuring
library(conflicted)#helps resolve errors for similar functions between packages
library(car)
#Specifying conflicts
conflicted::conflicts_prefer(dplyr::recode)
conflicts_prefer(plyr::mutate)
conflicts_prefer(dplyr::filter)
#important cover data (raw)
cover.pre <- read.csv("Raw Data/Emerald Lake Plant Data - pre.csv")
cover.23 <- read.csv("Raw Data/Emerald Lake Plant Data - 2023.csv")
cover.24 <- read.csv("Raw Data/Emerald Lake Plant Data - 2024.csv")
cover.25 <- read.csv("Raw Data/Emerald Lake Plant Data - 2025.csv")
#combine datasets
cover.comb <- rbind.fill(cover.pre,cover.23,cover.24,cover.25)
cover.comb <- as.data.frame(unclass(cover.comb),stringsAsFactors=TRUE)
cover.comb %<>%
mutate(removal = recode(removal,
"C" = "Control",
"R" = "Removal"))
#remove castilleja and environmental rows for analysis
cover.comb.clean <- cover.comb[!(cover.comb$functional_group %in% "environmental"),]
cover.comb.clean <- cover.comb.clean[!(cover.comb.clean$code %in% "CASE"),]
comb.cov <- subset(cover.comb.clean, select = c('year','plot','code','percent_cover'))
#filter for year/pre and calculate
emerald.pre <- comb.cov %>%
filter(year == "Pre") %>%
select(-c(year))
emerald.23 <- comb.cov %>%
filter (year == "2023") %>%
select(-c(year))
emerald.24 <- comb.cov %>%
filter (year == "2024") %>%
select(-c(year))
emerald.25 <- comb.cov %>%
filter (year == "2025") %>%
select(-c(year))
#convert to matrix format for diversity calculations
library(labdsv)#enables restructuring for ecological analysis
emerald.pre.matrix <- matrify(emerald.pre)
emerald.23.matrix <- matrify(emerald.23)
emerald.24.matrix <- matrify(emerald.24)
emerald.25.matrix <- matrify(emerald.25)
#---------------Diversity Calculations---------------#
library(vegan)#for calculating diversity
# Calculating Shannon diversity for plots
div.pre <- diversity(emerald.pre.matrix, index = "shannon")
div.23 <- diversity(emerald.23.matrix, index = "shannon")
div.24 <- diversity(emerald.24.matrix, index = "shannon")
div.25 <- diversity(emerald.25.matrix, index = "shannon")
# Calculating species richness for plots
rich.pre <- specnumber(emerald.pre.matrix)
rich.23 <- specnumber(emerald.23.matrix)
rich.24 <- specnumber(emerald.24.matrix)
rich.25 <- specnumber(emerald.25.matrix)
# Calculating species evenness for plots
even.pre <- diversity(emerald.pre.matrix, index = "shannon") / log(specnumber(emerald.pre.matrix))
even.23 <- diversity(emerald.23.matrix, index = "shannon") / log(specnumber(emerald.23.matrix))
even.24 <- diversity(emerald.24.matrix, index = "shannon") / log(specnumber(emerald.24.matrix))
even.25 <- diversity(emerald.25.matrix, index = "shannon") / log(specnumber(emerald.25.matrix))
#---------------Combining results and exporting---------------#
plot <- read.csv("Raw Data/Emerald Lake Plot Data - Info.csv")
plot %<>%
mutate(removal = recode(removal,
"C" = "Control",
"R" = "Removal"))
el.pre <- cbind(plot,div.pre,rich.pre,even.pre)
el.pre %<>%
plyr::mutate(year = 'pre') %>%
relocate(year) %>%
dplyr::rename(div = div.pre, rich = rich.pre, even = even.pre)
el.23 <- cbind(plot,div.23,rich.23,even.23)
el.23 %<>%
plyr::mutate(year = '2023') %>%
relocate(year) %>%
dplyr::rename(div = div.23, rich = rich.23, even = even.23)
el.24 <- cbind(plot,div.24,rich.24,even.24)
el.24 %<>%
plyr::mutate(year = '2024') %>%
relocate(year) %>%
dplyr::rename(div = div.24, rich = rich.24, even = even.24)
el.25 <- cbind(plot,div.25,rich.25,even.25)
el.25 %<>%
plyr::mutate(year = '2025') %>%
relocate(year) %>%
dplyr::rename(div = div.25, rich = rich.25, even = even.25)
diversity.pre <- rbind.fill(el.pre,el.23,el.24,el.25)
diversity <- rbind.fill(el.23,el.24,el.25)
write.csv(diversity, "Processed Data/Plant Diversity.csv", row.names=FALSE)
diversity.pre %<>%
mutate(year = recode(year,
"pre" = "0",
"2023" = "1",
"2024" = "2",
"2025" = "3",)) %>%
mutate(removal = recode(removal,
Control = "Present",
Removal = "Removed"))
#richness
rich.lmm <- lmer(rich ~ removal*year + (1|block) + (1|pair), data = diversity.pre)
summary(rich.lmm)
Anova(rich.lmm)#:removal:year p = 0.0008, Chisq = 16.8171, df = 3
emmeans(rich.lmm, pairwise ~ removal|year)
emmip(rich.lmm, removal ~ year)
#-------Bare Ground Analysis------#
envi.cover <- cover.comb %>%
filter(functional_group == 'environmental') %>%
subset(select = c('year','plot','pair','block','removal','litter','code','percent_cover')) %>%
mutate(year = recode(year,
"Pre" = "0",
"2023" = "1",
"2024" = "2",
"2025" = "3",))
envi.cover$pair <- as.factor(envi.cover$pair)
envi.cover$plot <- as.factor(envi.cover$plot)
envi.cover$block <- as.factor(envi.cover$block)
split_and_name <- function(df, column) {
# Get the dataframe name as a string
df_name <- deparse(substitute(df))
# Ensure column exists
if (!column %in% colnames(df)) {
stop("Column not found in dataframe")
}
# Split the dataframe by the column
df_list <- split(df, df[[column]])
# Remove dataframes with 0 rows
df_list <- df_list[sapply(df_list, nrow) > 0]
# If nothing remains, stop gracefully
if (length(df_list) == 0) {
warning("All split dataframes have 0 rows; nothing to assign.")
return(invisible(NULL))
}
# Make valid R names for safety
names(df_list) <- paste0(df_name, "_", make.names(names(df_list)))
# Assign each dataframe into the global environment
list2env(df_list, envir = .GlobalEnv)
# Return the list invisibly
invisible(df_list)
}
split_and_name(envi.cover, "code")
total.envi <- envi.cover %>%
group_by(year,plot,pair,block,removal,litter) %>%
summarise(
total_cover = sum(percent_cover, na.rm = TRUE)
)
#bare ground
bare.lmm <- lmer(percent_cover ~ litter*removal + (1|block) + (1|pair), data = envi.cover_bare_X2025)
summary(bare.lmm)
Anova(bare.lmm)#(Higher in Removal): p = 0.0032, Chisq = 8.6926, df = 1
emmeans(bare.lmm, pairwise ~ litter|removal)
#---------delta diversity Analysis---------#
library(statmod)
library(lme4)
library(emmeans) # for comparison of means
library(ggcharts)
library(ggthemes)
delta.div <- read.csv("Processed Data/Site Level Data - delta.csv")
conflicts_prefer(lme4::lmer)
conflicts_prefer(dplyr::mutate)
conflicts_prefer(dplyr::arrange)
div.lmm <- lmer(delta_rich ~ litter*removal + (1|block) + (1|pair), data = delta.div)
summary(div.lmm)
Anova(div.lmm)
setwd("~/Desktop/Castilleja/Data Analysis/RMBL Castilleja Experimental Project")
#----------Data importing, cleaning, and restructuring----------#
library(tidyverse)#for data wrangling and restructuring
library(magrittr)#for data wrangling and restructuring
library(plyr)#for data wrangling and restructuring
library(conflicted)#helps resolve errors for similar functions between packages
library(car)
library(broom)
conflicts_prefer(dplyr::summarise)
conflicts_prefer(dplyr::mutate)
#-----Assessing Nearest Neighbor data---------#
#Importing Species Data
cover <- read.csv("Processed Data/Neighbor Cover.csv")
#Sum for each species the number of times they apeard as a NN
nearest <- cover %>%
group_by(code, year) %>%
summarise(
total_cover = sum(percent_cover, na.rm = TRUE),
nn_count    = sum(nearest_neighbor, na.rm = TRUE),
.groups = "drop"
) %>%
group_by(year) %>%
mutate(
rel_abund_cover = total_cover / sum(total_cover, na.rm = TRUE),
nn_freq    = nn_count / sum(nn_count, na.rm = TRUE)
) %>%
ungroup()
nn_yearly <- nearest %>%
group_by(year) %>%
nest() %>%
mutate(
model = map(data, ~ lm(nn_freq ~ rel_abund_cover, data = .x)),
results = map2(model, data, ~ {
bind_cols(
.y,
as.data.frame(
predict(.x, newdata = .y, interval = "prediction", level = 0.95)
)
) %>%
mutate(
NN_association = case_when(
nn_freq > upr ~ "Frequent Neighbor",
nn_freq < lwr ~ "Infrequent Neighbor",
TRUE           ~ "As expected"
)
)
})
) %>%
select(year, results) %>%
unnest(results)
split_and_name <- function(df, column) {
# Get the dataframe name as a string
df_name <- deparse(substitute(df))
# Ensure column exists
if (!column %in% colnames(df)) stop("Column not found in dataframe")
# Split the dataframe by the column
df_list <- split(df, df[[column]])
# Make valid R names for safety
names(df_list) <- paste0(df_name, "_", make.names(names(df_list)))
# Assign each dataframe into the global environment
list2env(df_list, envir = .GlobalEnv)
# Return the list invisibly (optional)
invisible(df_list)
}
split_and_name(nn_yearly, "year")
pre.nearest <- ggplot(nn_yearly_Pre, aes(x = rel_abund_cover, y = nn_freq)) +
geom_smooth(method=lm , color="#582f0e", fill = "cornsilk3", se=TRUE) +
geom_point(aes(color = year, shape = year), size = 2.3) +
scale_color_manual( values=c("#936639")) +
scale_shape_manual(values = c(20)) +
geom_line(aes(y = fit)) +
geom_line(aes(y = lwr), linetype = "dashed", col = "black") +
geom_line(aes(y = upr), linetype = "dashed", col = "black") +
labs(x = "Relative Abundance", y = "Nearest Neighbor Frequency") +
geom_text(aes(0.101, 0.188811189), label = "ELGL", color = "grey22", nudge_y = - 0.007, size = 3) +
geom_text(aes(0.107, 0.020979021), label = "LIPO", color = "grey22", nudge_y = - 0.007, size = 3) +
theme_minimal() +
ggtitle("2023 Pre") +
theme(legend.position = "none") +
theme(strip.text = element_text(size = 15),
strip.background = element_blank(),
panel.border = element_rect(fill = "transparent",
color = "gray23", linewidth = 0.12)) +
theme(panel.background = element_rect(fill='transparent'), #transparent panel bg
plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg
legend.background = element_rect(fill='transparent'), #transparent legend bg
legend.box.background = element_rect(fill='transparent')) + #transparent legend pane
theme(plot.title = element_text(hjust = 0.92, vjust= -0.12))
pre.nearest
y1.nearest <- ggplot(nn_yearly_X2023, aes(x = rel_abund_cover, y = nn_freq)) +
geom_smooth(method=lm , color="#582f0e", fill = "cornsilk3", se=TRUE) +
geom_point(aes(color = year, shape = year), size = 2.3) +
scale_color_manual( values=c("#936639")) +
scale_shape_manual(values = c(20)) +
geom_line(aes(y = fit)) +
geom_line(aes(y = lwr), linetype = "dashed", col = "black") +
geom_line(aes(y = upr), linetype = "dashed", col = "black") +
labs(x = "Relative Abundance", y = "Nearest Neighbor Frequency") +
theme_minimal() +
geom_text(aes(0.0985, 0.24590164), label = "ELGL", color = "grey22", nudge_y = - 0.0075, size = 3) +
geom_text(aes(0.0475, 0.16393443), label = "LUAR", color = "grey22", nudge_y = - 0.0075, size = 3) +
ggtitle("2023 Post") +
theme(legend.position = "none") +
theme(strip.text = element_text(size = 15),
strip.background = element_blank(),
panel.border = element_rect(fill = "transparent",
color = "gray23", linewidth = 0.12)) +
theme(panel.background = element_rect(fill='transparent'), #transparent panel bg
plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg
legend.background = element_rect(fill='transparent'), #transparent legend bg
legend.box.background = element_rect(fill='transparent')) + #transparent legend pane
theme(plot.title = element_text(hjust = 0.92, vjust= -0.12))
y1.nearest
y2.nearest <- ggplot(nn_yearly_X2024, aes(x = rel_abund_cover, y = nn_freq)) +
geom_smooth(method=lm , color="#582f0e", fill = "cornsilk3", se=TRUE) +
geom_point(aes(color = year, shape = year), size = 2.3) +
scale_color_manual( values=c("#936639")) +
scale_shape_manual(values = c(20)) +
geom_line(aes(y = fit)) +
geom_line(aes(y = lwr), linetype = "dashed", col = "black") +
geom_line(aes(y = upr), linetype = "dashed", col = "black") +
labs(x = "Relative Abundance", y = "Nearest Neighbor Frequency") +
theme_minimal() +
ggtitle("2024") +
theme(legend.position = "none") +
geom_text(aes(0.0435, 0.13253012), label = "ELGL", color = "grey22", nudge_y = - 0.005, size = 3) +
geom_text(aes(0.058, 0.09638554), label = "MESP", color = "grey22", nudge_y = 0.005, size = 3) +
theme(strip.text = element_text(size = 15),
strip.background = element_blank(),
panel.border = element_rect(fill = "transparent",
color = "gray23", linewidth = 0.12)) +
theme(panel.background = element_rect(fill='transparent'), #transparent panel bg
plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg
legend.background = element_rect(fill='transparent'), #transparent legend bg
legend.box.background = element_rect(fill='transparent')) + #transparent legend pane
theme(plot.title = element_text(hjust = 0.92, vjust= -0.12))
y2.nearest
y3.nearest <- ggplot(nn_yearly_X2025, aes(x = rel_abund_cover, y = nn_freq)) +
geom_smooth(method=lm , color="#582f0e", fill = "cornsilk3", se=TRUE) +
geom_point(aes(color = year, shape = year), size = 2.3) +
scale_color_manual( values=c("#936639")) +
scale_shape_manual(values = c(20)) +
geom_line(aes(y = fit)) +
geom_line(aes(y = lwr), linetype = "dashed", col = "black") +
geom_line(aes(y = upr), linetype = "dashed", col = "black") +
labs(x = "Relative Abundance", y = "Nearest Neighbor Frequency") +
theme_minimal() +
geom_text(aes(0.1069609991, 0.04210526), label = "HEQU", color = "grey22", nudge_y = - 0.004, size = 3) +
geom_text(aes(0.0668506244, 0.11578947), label = "ELGL", color = "grey22", nudge_y = - 0.004, size = 3) +
geom_text(aes(0.0391147271, 0.08421053), label = "POGR", color = "grey22", nudge_y = - 0.004, size = 3) +
ggtitle("2025") +
theme(legend.position = "none") +
theme(strip.text = element_text(size = 15),
strip.background = element_blank(),
panel.border = element_rect(fill = "transparent",
color = "gray23", linewidth = 0.12)) +
theme(panel.background = element_rect(fill='transparent'), #transparent panel bg
plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg
legend.background = element_rect(fill='transparent'), #transparent legend bg
legend.box.background = element_rect(fill='transparent')) + #transparent legend pane
theme(plot.title = element_text(hjust = 0.92, vjust= -0.12))
y3.nearest
nearestplots <- ggarrange(pre.nearest, y1.nearest, y2.nearest, y3.nearest,
labels = c("A", "B","C", "D"),
nrow = 2, ncol = 2)
nearestplots
